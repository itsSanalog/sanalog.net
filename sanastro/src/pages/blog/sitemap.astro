---
import { getEntry } from "astro:content";
import BlogLayout from "../../layouts/BlogLayout.astro";

const sitemap = await getEntry("blog", "sitemap");
const { Content } = await sitemap.render();
---

<!-- IMPORTANT: this file overwrites /blog/sitemap that would have been generated by [...slug].astro, or at least i think it does. -->

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.4.1/+esm';
  
  mermaid.initialize({ 
    startOnLoad: true,
    theme: document.body.classList.contains("theme-light") ? "default" : "dark",
  });
  
  // Re-render diagram on theme toggle
  document.addEventListener('DOMContentLoaded', () => {
    const themeToggle = document.querySelector("#theme-toggle");
    if (themeToggle) {
      themeToggle.addEventListener("click", () => {
        // Wait for theme class to update
        setTimeout(() => {
          const isLightTheme = document.body.classList.contains('theme-light');
          
          // Re-render with appropriate theme
          mermaid.initialize({ 
            theme: isLightTheme ? "default" : "dark",
            startOnLoad: false,
            flowchart: {
              curve: 'basis',
              diagramPadding: 8,
              nodeSpacing: 80,
              rankSpacing: 120
            }
          });
          
          // Get all mermaid diagrams and re-render them
          document.querySelectorAll(".mermaid").forEach(diagram => {
            // Store zoom/pan state if possible
            const svg = diagram.querySelector('svg');
            let transform = '';
            if (svg) {
              const g = svg.querySelector('g');
              if (g) transform = g.getAttribute('transform') || '';
            }
            
            // Remove the 'data-processed' attribute to allow re-rendering
            diagram.removeAttribute('data-processed');
            
            // Reinitialize the diagram
            mermaid.init(undefined, diagram);
            
            // Restore transform after a delay to ensure rendering is complete
            if (transform) {
              setTimeout(() => {
                const newSvg = diagram.querySelector('svg');
                if (newSvg) {
                  const newG = newSvg.querySelector('g');
                  if (newG) newG.setAttribute('transform', transform);
                }
              }, 200);
            }
          });
        }, 100);
      });
    }
  });

  // Add zoom and pan functionality after Mermaid renders
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      // Find the SVG rendered by Mermaid
      const svg = document.querySelector('.mermaid svg');
      if (!svg) return;
      
      // Make SVG responsive
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      
      // Store original viewBox
      const originalViewBox = svg.getAttribute('viewBox');
      
      // Variables for pan and zoom
      let scale = 1;
      let translateX = 0;
      let translateY = 0;
      let isDragging = false;
      let startX, startY;
      
      // Find the transform group
      const g = svg.querySelector('g');
      if (!g) return;
      
      // Mouse events for dragging/panning
      svg.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Only left mouse button
        isDragging = true;
        svg.style.cursor = 'grabbing';
        startX = e.clientX;
        startY = e.clientY;
        e.preventDefault();
      });
      
      window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const dx = (e.clientX - startX) / scale;
        const dy = (e.clientY - startY) / scale;
        
        translateX += dx;
        translateY += dy;
        
        startX = e.clientX;
        startY = e.clientY;
        
        updateTransform();
      });
      
      window.addEventListener('mouseup', () => {
        isDragging = false;
        svg.style.cursor = 'grab';
      });
      
      // Mouse wheel for zooming
      svg.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        // Determine zoom direction
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        
        // Get mouse position relative to SVG
        const rect = svg.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Calculate zoom centered on mouse position
        const oldScale = scale;
        scale *= zoomFactor;
        
        // Set reasonable limits
        if (scale < 0.2) scale = 0.2;
        if (scale > 5) scale = 5;
        
        // Adjust translation to zoom toward mouse position
        const factor = scale / oldScale - 1;
        translateX -= mouseX * factor / oldScale;
        translateY -= mouseY * factor / oldScale;
        
        updateTransform();
      });
      
      // Update transform with current values
      function updateTransform() {
        g.setAttribute('transform', \`translate(\${translateX}, \${translateY}) scale(\${scale})\`);
      }
      
      // Initialize cursor
      svg.style.cursor = 'grab';
    }, 1000); // Delay to ensure Mermaid has rendered
  });
</script>

<BlogLayout title="Sitemap">
  <content>
    <h1>Sitemap</h1>
    
    <p class="muted"><em>..mapping pages makes this more of an index</em></p>
    <p class="mmb">A sitemap of sanaBlog. Work in progress.</p>
    
    <Content />

  </content>
</BlogLayout>