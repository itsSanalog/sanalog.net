---
import { getEntry } from "astro:content";
import BlogLayout from "../../layouts/BlogLayout.astro";

const sitemap = await getEntry("blog", "sitemap");
const { Content } = await sitemap.render();
---

<!-- IMPORTANT: this file overwrites /blog/sitemap that would have been generated by [...slug].astro, or at least i think it does. -->

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.4.1/+esm';
  
  mermaid.initialize({ 
    startOnLoad: true,
    theme: document.querySelector('body').classList.contains("theme-light") ? "light" : "dark",
    mindmap: {
      nodeSpacing: 120,
      rankSpacing: 300,
      padding: 50,
      useMaxWidth: true,
    }
  });
  
  // Setup interaction after mermaid renders
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(setupInteractivity, 800);
  });
  
  function setupInteractivity() {
    const container = document.querySelector('.mermaid');
    const svg = container?.querySelector('svg');
    if (!svg) return;
    
    // Add CSS
    const style = document.createElement('style');
    style.textContent = `
      .mermaid svg {
        background-color: var(--color-bg-primary);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        cursor: grab;
      }
      .mermaid svg.grabbing {
        cursor: grabbing;
      }
      .mermaid .node {
        transition: all 0.2s ease;
      }
      .mermaid .node:not(.countNode):hover {
        filter: brightness(1.2);
        transform: scale(1.05);
      }
      .mermaid .edgePath {
        transition: stroke-width 0.2s ease;
      }
      .mermaid .edgePath:hover {
        stroke-width: 3px;
      }
    `;
    document.head.appendChild(style);

    // Make SVG responsive
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    
    // Setup pan/zoom state
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX, startY;
    
    // Get the transform group
    const g = svg.querySelector('g');
    if (!g) return;
    
    // Update transform helper
    function updateTransform() {
      g.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
    }
    
    // Mouse events for dragging
    svg.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // Only left mouse button
      isDragging = true;
      svg.classList.add('grabbing');
      startX = e.clientX;
      startY = e.clientY;
      e.preventDefault();
    });
    
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const dx = (e.clientX - startX) / scale;
      const dy = (e.clientY - startY) / scale;
      
      translateX += dx;
      translateY += dy;
      
      startX = e.clientX;
      startY = e.clientY;
      
      updateTransform();
    });
    
    window.addEventListener('mouseup', () => {
      isDragging = false;
      svg.classList.remove('grabbing');
    });
    
    // Wheel zoom
    svg.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      
      // Get mouse position relative to SVG
      const svgRect = svg.getBoundingClientRect();
      const mouseX = e.clientX - svgRect.left;
      const mouseY = e.clientY - svgRect.top;
      
      // Calculate scaling around mouse position
      const oldScale = scale;
      scale *= zoomFactor;
      if (scale < 0.1) scale = 0.1;
      if (scale > 10) scale = 10;
      
      // Adjust translation to zoom toward mouse position
      const scaleFactor = scale / oldScale - 1;
      translateX -= mouseX * scaleFactor / oldScale;
      translateY -= mouseY * scaleFactor / oldScale;
      
      updateTransform();
    });
    
    // Double-click to reset view
    svg.addEventListener('dblclick', (e) => {
      if (e.target.closest('.node')) return; // Don't reset if clicking on a node
      
      scale = 1;
      translateX = 0;
      translateY = 0;
      updateTransform();
    });
    
    // Make nodes clickable - navigation to respective pages
    const nodes = svg.querySelectorAll('.node');
    nodes.forEach(node => {
      // Skip if this is a content count node
      if (node.classList.contains('countNode')) return;
      
      // Extract node ID for navigation
      const nodeId = node.id;
      if (!nodeId) return;
      
      node.style.cursor = 'pointer';
      node.addEventListener('click', () => {
        // Handle home node specially
        if (nodeId === 'home') {
          window.location.href = '/';
          return;
        }
        
        // Convert from mermaid node ID to path
        // e.g., home_blog_reviews_music -> /blog/reviews/music
        let path = '/' + nodeId.replace(/^home_/, '').replace(/_/g, '/');
        
        window.location.href = path;
      });
      
      // Add hover effect
      node.addEventListener('mouseenter', () => {
        // Highlight connected edges
        const edges = svg.querySelectorAll('.edgePath');
        edges.forEach(edge => {
          if (edge.id.includes(nodeId)) {
            edge.classList.add('highlight');
          }
        });
      });
      
      node.addEventListener('mouseleave', () => {
        // Remove highlight from edges
        const edges = svg.querySelectorAll('.edgePath.highlight');
        edges.forEach(edge => {
          edge.classList.remove('highlight');
        });
      });
    });
  }
  
  // Update diagram when theme changes
  const themeToggle = document.querySelector("#theme-toggle");
  if (themeToggle) {
    themeToggle.addEventListener("click", () => {
      setTimeout(() => {
        const isLightTheme = document.body.classList.contains('theme-light');
        mermaid.initialize({ 
          theme: isLightTheme ? 'light' : 'dark',
          startOnLoad: false,
          mindmap: {
            nodeSpacing: 120,
            rankSpacing: 300,
            padding: 50,
            useMaxWidth: true,
          }
        });
        mermaid.init(undefined, document.querySelectorAll(".mermaid:not([data-processed])"));
      }, 100);
    });
  }
</script>



<style>
  .mermaid {
    min-height: 600px;
  }
  
  :global(.theme-light) .mermaid .node rect,
  :global(.theme-light) .mermaid .node circle,
  :global(.theme-light) .mermaid .node ellipse,
  :global(.theme-light) .mermaid .node polygon {
    fill: #f5f5f5 !important;
    stroke: #6272a4 !important;
  }
  
  :global(.theme-light) .mermaid .node.countNode rect,
  :global(.theme-light) .mermaid .node.countNode circle,
  :global(.theme-light) .mermaid .node.countNode ellipse,
  :global(.theme-light) .mermaid .node.countNode polygon {
    fill: #e0e0e0 !important;
    stroke: #50fa7b !important;
  }
  
  :global(.theme-light) .mermaid .edgePath .path {
    stroke: #adb5bd !important;
  }
  
  :global(.theme-light) .mermaid .edgePath.highlight .path {
    stroke: #ff79c6 !important;
    stroke-width: 2px !important;
  }
</style>



<BlogLayout title="Sitemap">
  <content>
    <h1>sitemap</h1>
    
    <p class="muted"><em>..mapping pages makes this more of an index</em></p>
    
    <p class="mmb">A sitemap of sanaBlog. Work in progress.</p>

    <Content />

  </content>
</BlogLayout>